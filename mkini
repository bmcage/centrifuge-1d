#!/usr/bin/python
import csv

from os import makedirs, path, sep
from optparse import OptionParser
from config import ModulesManager
from const import CSV_DIR, INI_DIR

modman = ModulesManager()

base_module = modman.find_module('base', submodule='csv_parse')

def parse_input():

    usage_str = (
         '\n\t%prog <csv_ID>'
         '\n\nwhere'
         '\n  csv_ID:'
         '\n        ID of the csv file. By default will be searched for '
         '\n        the file ''./sources/csv/<csv_ID>[.cvs]'' ')

    optparser = OptionParser(usage=usage_str)
    optparser.add_option('-l', '--list', dest='list', action="store_true",
                         default=False,
                         help="Lists all available CSV files")

    (options, args) = optparser.parse_args()

    len_args = len(args)

    if len_args == 0:
        if options.list:
            from os import listdir

            print('\n'.join(sorted(listdir(CSV_DIR))))
        else:
            optparser.print_help()
        exit(0)

    csv_filename = CSV_DIR + sep + args[0]

    if path.exists(csv_filename):
            options.csv_filename = csv_filename
    elif  path.exists(csv_filename + '.csv'):
        options.csv_filename = csv_filename + '.csv'
    else:
        print('CSV file does not exist:{}'.format(csv_filename))
        exit(1)

    if not path.exists(INI_DIR):
        makedirs(INI_DIR)

    return options

def get_module_function(function_name, module, base_module=base_module):
    if hasattr(module, function_name):
        function = getattr(module, function_name)
    else:
        function = getattr(base_module, function_name)

    return function

required_fields = ['exp_type', 'id', 'exp_no', 'tube_no']

def csv_has_required_fields(csv_fields):

    result = True

    for field in required_fields:
        if not field in csv_fields:
            print("CSV file: missing identifier: '%s' "% field)
            result = False

    return result

def read_CSV_row(data, exp_type, row, indexes, csv_fields):

    experiment_id = row[indexes['id']]
    experiment_no = row[indexes['exp_no']]
    tube_number   = row[indexes['tube_no']]
    exp_type      = row[indexes['exp_type']]

    if not experiment_id in data:
        data[experiment_id]={}
    if not experiment_no in data[experiment_id]:
        data[experiment_id][experiment_no]={}

    experiment_data = data[experiment_id][experiment_no]
    if not tube_number in experiment_data:
        experiment_data[tube_number]  = {}

        for field in csv_fields:
            if not field in required_fields:
                experiment_data[tube_number][field] = []

    for (descriptor, value) in zip(csv_fields, row):
        if not descriptor in required_fields:
            experiment_data[tube_number][descriptor].append(value)

    if not 'exp_type' in experiment_data[tube_number]:
        experiment_data[tube_number]['exp_type'] = row[indexes['exp_type']]
    elif experiment_data[tube_number]['exp_type'] != row[indexes['exp_type']]:
        raise ValueError(experiment_id +': experiment ' + experiment_no
                         + ' - cannot have different experiment'
                         + ' types: ', value, ' and '
                         + experiment_data[tube_number]['exp_type'])

def CSV2data(csv_filename):

    f_csv = open(csv_filename)
    csv_data = csv.reader(f_csv)

    print('Reading CSV file... ', end="")

    csv_fields = next(csv_data)

    indexes = {field: csv_fields.index(field) for field in csv_fields}

    if not csv_has_required_fields(indexes.keys()):
        print('CSV error: cannot process CSV file, aborting...')
        exit(1)

    exp_type_idx = indexes['exp_type']

    data = {}

    for row in csv_data:
        experiment_type = row[exp_type_idx]

        module = modman.find_module(experiment_type, submodule='csv_parse')

        skip         = get_module_function('skip', module)

        ini_fields = []
        ini_fields.extend(csv_fields)

        for field in required_fields:
            ini_fields.remove(field)

        if skip(experiment_type, row, indexes): continue

        read_CSV_row(data, experiment_type, row, indexes, csv_fields)

    f_csv.close()

    print('Done.')

    return data

def write2ini(experiment_data, filename):

    fout = open(filename, mode='w', encoding='utf-8')
    fout.write('[experiment-data]\n')

    for (descriptor, value) in experiment_data.items():
        if descriptor == 'exp_type':
            fout.write("{:8} = '{}'\n".format(descriptor, value))
        else:
            fout.write('{:8} = [{}]\n'.format(descriptor,
                                                          ', '.join(value)))
    fout.close()

def data2ini(data, output_dir):

    print('\nCreating data inifiles...')

    for (experiment_id, exp_id_struct) in data.items():
        exp_out_dir  = output_dir + sep + experiment_id + '/'

        if not path.exists(exp_out_dir):
            makedirs(exp_out_dir)

        print('    Processing experiment(s) with ID: %s...' % experiment_id)

        for (experiment_no, exp_no_struct) in exp_id_struct.items():

            print('\tProcessing experiment number: %s... '
                  % experiment_no, end="")

            for (tube_no, exp_data) in exp_no_struct.items():

                filename = (exp_out_dir + 'experiment_' + experiment_no
                            + '-tube' + tube_no + '.ini')

                write2ini(exp_data, filename)

            print('Done.')

        print('    Creating default inifile for ID %s...', end = '')

        default_ini = exp_out_dir + '/defaults.ini'

        if path.exists(default_ini):
            print('\n        File "defaults.ini" already exists. Skipping...')
        else:
            fout = open(default_ini, mode='w', encoding='utf-8')
            fout.write('[base]\n')
            # TODO: add some default stuff that will be added to the defaults
            print('Done.')

    print('Done.')

if __name__ == "__main__":
    options = parse_input()
    data    = CSV2data(options.csv_filename)

    data2ini(data, INI_DIR)
