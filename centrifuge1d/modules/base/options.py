import numpy as np
from ..shared.utils import test_related_options
from ..shared.measurements import MEASUREMENTS_NAMES

PARENTAL_MODULES = []

def gen_measurements(cfg):
    names   = [(name, None) for name in MEASUREMENTS_NAMES.values() \
               if not name is None]
    xvalues = [(name + '_xvalues', None) for name in MEASUREMENTS_NAMES.values()  \
               if not name is None]
    weights = [(name + '_weights', 1.0) for name in MEASUREMENTS_NAMES.values() \
               if not name is None]
    baselines = [(name + '_baseline', None) for name in MEASUREMENTS_NAMES.values()  \
                 if not name is None]

    return names + xvalues + weights + baselines

CONFIG_OPTIONS = ['exp_type',
                  'ks',
                  ('r0', None), ('re', None), ('wl0', None), 'l0', 'duration',
                  ('ww0', None),
                  'fh_duration', 'r0_fall',
                  ('acceleration_duration', 21.),
                  'include_acceleration',
                  # solver options
                  'atol', 'rtol',
                  'first_step_size',
                  'max_steps', 'max_step_size',
                  ('compute_initcond', 'yp0'),
                  # defaults
                  ('g', 981),   # g accelleration in cm/s
                  ('tube_no', None),
                  ('tube_diam', None),
                  'fl1',
                  (lambda cfg: cfg.get_value('fl1') > 0.0,
                      ['ks1'], [('ks1', -1.0)]),
                  'fl2',
                  (lambda cfg: cfg.get_value('fl2') > 0.0,
                      ['ks2'], [('ks2', -1.0)]),
                  ('density', 1.0), ('viscosity', 1.0),
                  # output
                  ('show_figures', True),
                  ('save_figures', False), ('separate_figures', False),
                  ('save_data', True),
                  ('verbosity', 1),
                  # solver options
                  ('always_restart_solver', False),

                  # dependent options
                  (lambda cfg: not (cfg.get_value('duration') == 0.0),
                    ['omega']),
                  (lambda cfg: cfg.get_value('include_acceleration'),
                    ['deceleration_duration'],
                    [('deceleration_duration', 0.0)]),
                  # measurements and referencing parameters
                  ('smoothing', {}),
                  gen_measurements,
                  ('ww1', None), ('gf_mo_tara', None), ('gf_mt_tara', None),
                  'gf_mt_calibration_curve', 'gf_mo_calibration_curve',
                  ('measurements_scale_coefs', None),
                  ('cf_weights', 1.0), ('measurements_diff', []),
                  ('measurements_keep', None), ('measurements_remove', None),
                  ('show_original_measurements', None),

                  ('descr', None), ('re', None),
                  ('mo_gc_calibration_curve', None),

                  ('rpms_file', None),

                  # options generated by mkini
                  ('measurements_length', -1)
                 ]

INTERNAL_OPTIONS = ['omega2g_fns', 'find_omega2g', 't0', 'omega_start',
                    'calc_gf_mt', 'calc_gf_mo', 'calc_gcf_mo',
                    'tube_crosssectional_area', 'z_size']

EXCLUDE_FROM_MODEL = ['measurements_length', 'omega2g_fns', 'r0',
                      'gf_mt_calibration_curve', 'gf_mo_calibration_curve',
                      'tube_diam', 'ww0', 'ww1', 'gf_mo_tara', 'gf_mt_tara']

PROVIDE_OPTIONS = []

OPTIONS_ITERABLE_LISTS = ['r0', 're', 'l0', 'omega', 'porosity',
                           'duration', 'fh_duration', 'deceleration_duration']

def check_cfg(cfg):
    """
      Perform additional test on 'cfg' to validate it. Test for expected value,
      type etc. of supplied values should be done here. Checking for the
      presence of mandatory and dependent options  is done by default.
      Additional information informing user about failed test(s) should be
      supplied. The return value of this function is type boolean.
    """
    if not cfg.get_value('include_acceleration'):
        value = cfg.get_value('deceleration_duration')
        is_list = (type(value) in [list, tuple])
        if (is_list and any(value)) or (not is_list and value):
            print("Option 'deceleration_duration' can't have a positive value "
                  "if 'include_acceleration' is False.")
            return False

    for options_names in (('r0', 're'), ):
        if not test_related_options(cfg, options_names, mode='exact1'):
            return False

    for options_names in (('wl0', 'ww0'), ('wl1', 'ww1')):
        if not test_related_options(cfg, options_names, mode='atmost1'):
            return False

    if cfg.get_value('tube_diam') is None:
        print('Tube diameter is not specified.')
        return False

    for F_name in ('gf_mo', 'gf_mt'):
        F = cfg.get_value(F_name)

        if (F is None): continue

        if F_name in ('gf_mo'):
            MO_GC = cfg.get_value('mo_gc_calibration_curve')

            if MO_GC is None:
                print('No calibration curve for expelled water was '
                      'specified. Cannot continue. Exiting...')
                return False

            if ((not type(MO_GC) in (list, tuple))
                or (not type(MO_GC[0]) in (list, tuple))):
                print("Calibration curve must by of type 'list' or 'tuple': ",
                      MO_GC)
                return False

            if not len(MO_GC) > 1:
                print('Calibration curve must by of length at least 2: ',
                      MO_GC)
                return False

        if not cfg.get_value('mo_gc_calibration_curve'):
            print("WARNING: 'MO_GC_calibration_curve' is not set. This may "
                  "lead to problems. You have been warned:)")
    if cfg.get_value('rpms_file') is not None:
        # 1. does file exist ?
        rpms_file = cfg.get_value('rpms_file')
        import os.path
        if not os.path.isfile(rpms_file):
            print ("rpms_file given, %s, does not exist" % rpms_file)
            return False
        # 2. if file given, accel/decel should not be present
        if cfg.get_value('include_acceleration'):
            print ("rpms_file given, include_acceleration must be False!")
            return False
        # 3. if rpms_file given, omega should be None
        if len(cfg.get_value('omega')) is not 1:
            print ("rpms_file given, omega should be value")
            return False


    return True

def adjust_cfg(cfg):
    """
      This method is called after the configuration is read from a file
      (and was validated). Allows to process configuration data supplied
       by configuration file(s), e.g. allocate the discretized interval
       based on the discretization type and number of inner points.
    """
    from ..shared.functions import (find_omega2g, find_omega2g_fh,
                                    find_omega2g_dec, readrpms_file,
                                    find_omega2g_rpms)

    # NOTE: conversion of omega from rpm to radians is done inside the
    #       read() method of class Measurements
    omega_acc = (lambda model, t_total:
                 find_omega2g(t_total-model.t0, model.omega, model.omega_start,
                              model.g, model.include_acceleration,
                              model.acceleration_duration))
    omega_dec = (lambda model, t_total:
                 find_omega2g_dec(t_total - model.t0, model.deceleration_duration,
                                  model.omega_start, model.g))
    omega_fh = lambda model, t_total: find_omega2g_fh(model.r0_fall)

    if cfg.get_value("rpms_file"):
        # we need to determine rpms based on file data!
        omega_acc = (lambda model, t_total:
                     find_omega2g_rpms(t_total-model.t0, model.g,
                                       cfg.get_value("datarpms"))
                     )

    cfg.set_value('omega2g_fns', {'a': omega_acc, 'g': omega_fh,
                                  'd': omega_dec})

    # if r0 was set (but not rE), we set rE (and discard r0)
    if not cfg.get_value('re'):
        r0_np  = np.asarray(cfg.get_value('r0'), dtype=float)
        l0_np  = np.asarray(cfg.get_value('l0'), dtype=float)
        fl2_np = np.asarray(cfg.get_value('fl2'), dtype=float)

        rE = r0_np + l0_np + fl2_np
        if not np.isscalar(rE):
            rE = list(rE)
        cfg.set_value('re', rE)

    cfg.set_value('calc_gf_mt', True)
    cfg.set_value('calc_gcf_mo', False)
    if not cfg.get_value('mo_gc_calibration_curve') is None:
        cfg.set_value('calc_gf_mo', True)

    tube_crosssectional_area = \
      np.pi * np.power(cfg.get_value('tube_diam'), 2) / 4.
    cfg.set_value('tube_crosssectional_area', tube_crosssectional_area)

    # if ww0 (ww1) was provided, we set wl0 (wl1)
    for name in ('ww0', 'ww1'):
        value = cfg.get_value(name)

        if value:
            new_value = (np.asarray(value, dtype=float)
                         / cfg.get_value('density') / tube_crosssectional_area)
            if np.isscalar(new_value):
                cfg.set_value('wl'+name[2], [new_value])
            else:
                cfg.set_value('wl'+name[2], list(new_value))

    duration   = cfg.get_value('duration')
    d_duration = cfg.get_value('deceleration_duration')
    if type(d_duration) is list:
        if type(duration) is list:
            duration = [c_dur - d_dur for (c_dur, d_dur) in zip(duration,
                                                                d_duration)]
        else:
            duration = [duration - d_dur for d_dur in d_duration]
    else:
        if type(duration) is list:
            duration = [c_dur - d_duration for c_dur in duration]
        else:
            duration -= d_duration
    cfg.set_value('duration', duration)

def prior_adjust_cfg(cfg):
    """
      This function is called prior to the adjust_cfg() function. It is intended
      for pre-data initialization. Mainly, if a descendent module provides an
      option, this option may not be present in the configuration, but the
      parental module may need to use the value in adjust_cfg. So here the
      needed value can be specified.
    """
    return True
